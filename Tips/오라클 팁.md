# 오라클 팁
## 설치
### 오라클 클라이언트 설치 (12c)
- 다운로드: zip 파일 안에 setup.ini도 있는 파일
- 압축 풀고 setup.exe 실행
- 사용자 정의
    - Oracle 홈 사용자 선택: Windows 내장 계정 사용
    - 사용 가능한 제품 구성 요소: 모든 제품 설치
    - 설치 위치 지정: 원하는 위치로 설정
- Scheduler 에이전트: 기본값으로 입력되었을 텐데 그대로 이용

### Toad for oracle 설치 (13.1.1.5)
- Welcome: Next 누르기
- License Agreement: Next 누르기
- Product Licensing: 라이선스가 있는지 확인. 없으면 Add License 눌러서 등록
- Destination Selection: 원하는 위치로 설정

### 설치 이후
- 설치 후 환경변수 등록
    - 예: `D:\Tools\Oracle\product\12.2.0\client_1\bin`
- tnsnames.ora 등록

-------------
## 콘솔로 접속
- cmd/powershell > `sqlplus 사용자명/비밀번호@DB명`으로 접속
    - 예 : `sqlplus scott/tiger@ORCL`

- 현재 접속한 계정이 소유한 프로시저 목록 보기
    - `SELECT OBJECT_NAME FROM USER_PROCEDURES WHERE OBJECT_TYPE = 'PROCEDURE';`

- 콘솔로 실행 시 시간 표기
    - `SQL> set timing on`
    - stackoverflow.com/questions/8401270
--------------
## 합계
- 한 행에서 나머지 열들의 합계 구하기
    - `SUM(CASE WHEN APT_TYPE 1 OR APT_TYPE=2... THEN 1 END) AS "TEST"`
    - COUNT와 똑같이 SUM 안에도 CASE WHEN 조건 넣기
    - 우리나라 시군구 개수를 알면 좋다
        - 시 75, 군 82, 구 69 (합 226개)
        - vo.la/O5ATKu

- 전체 합계 행 출력
	- www.gurubee.net/article/59196
	- 쿼리문을 WITH로 묶은 다음 그룹화할 열만 제외한 후 나머진 전부 sum을 붙인다
	- 그리고 group by rollup(그룹명)을 쓴다.
	- 예
        ```sql
        WITH SUB4_TEMP AS (...)
		SELECT
			SUB4_TEMP.EMD_NAME
			, SUM(SUB4_TEMP.CNT)
			, SUM(SUB4_TEMP.CNT2)
			, SUM(SUB4_TEMP.CNT3)
			, SUM(SUB4_TEMP.GRADE1)
			, SUM(SUB4_TEMP.GRADE2)
			, SUM(SUB4_TEMP.GRADE3)
			, SUM(SUB4_TEMP.GRADE4)
		FROM SUB4_TEMP
		GROUP BY ROLLUP(EMD_NAME)
        ```
	- 여러 항목으로 ROLLUP할 때 소계 안 나오게 하려면 괄호로 한번 더 묶기
        - 예 : `GROUP BY ROLLUP((SREG, SEUB))`
    - 합계에 이름 붙이기 : 그룹으로 묶은 칼럼에 NVL 사용
        - 예 : `NVL(T1_BLD.AS1, '합계') AS "시도"`
        - vo.la/TPf0SK
    - 합계에 이름 붙이기: GROUPING 또는 GROUPING_ID 활용
        - GROUPING: 1개 칼럼으로 구분할 때
        - GROUPING_ID: 여러 칼럼으로 구분할 때
        - 참고
            - gent.tistory.com/279 (archive.is/T6Tig)
            - vo.la/nFj9q (asktom.oracle.com, archive.is/EUaZQ)

- 전체 합계 행이 가장 먼저 나오게 하기
    - NULLS FIRST 활용
    - 예 : ORDER BY BJD.AS1 NULLS FIRST, BJD.AS2 NULLS FIRST;
    - 보통 정렬은 REG,EUB 기준이다. (서울부터 시작)
	
- 소계만 나오고 전체 총계(GRAND TOTAL)은 안 나오게 하기
	- vo.la/4jQuMl
	- GROUPING SETS 활용
	- 예 : 
        ```SQL
        GROUP BY GROUPING SETS((REGION_TEMP_2.SIDO_CODE, REGION_TEMP_2.REG, REGION_TEMP_2.EUB, REGION_TEMP_2.APT_TYPE))
        ```
	- 여기서 총계까지 나오게 하려면
        ```SQL
        GROUP BY GROUPING SETS((REGION_TEMP_2.SIDO_CODE, REGION_TEMP_2.REG, REGION_TEMP_2.EUB, REGION_TEMP_2.APT_TYPE), ())
        ```
		- 옆에 빈 괄호를 하나 더 추가하면 된다.
--------------
## 정렬
- 정렬
    - 문자열로 된 숫자 순서 바르게 정렬
        ```SQL
        TO_NUMBER(REGEXP_SUBSTR(EXPOS_HO_NM, '[0-9]+'))
        ```
		
- 숫자 정렬 (예 : 지상10층 다음 지상2층 나오는 문제 해결)
	- koeiking11.tistory.com/437
	- 정규표현식 이용
        ```SQL
        ORDER BY REGEXP_REPLACE("층", '[0-9]'), TO_NUMBER(REGEXP_REPLACE("층", '[^0-9]'))
        ```
	- 참고 : `ORDER BY CONVERT("층", 'ISO2022-KR')` 
	- 이 방법은 정렬 순서를 한글>숫자>영문으로 바꿔줄 뿐, 1층 다음 10층 나오는 문제는 해결 안 된다!

- ORDER BY DECODE/CASE로 정렬
  - 간단한 설명 : highello.tistory.com/24
	- 자세한 설명 : www.haguangho.com/80
	- 응용도 가능
        ```SQL
        ORDER BY REGEXP_REPLACE(
			CASE
				WHEN "층" LIKE '지상%' THEN 1
				WHEN "층" LIKE '지하%' THEN 2
				ELSE 3
			END, '[0-9]')
        ```
			
- LEVEL 사용 시 LEVEL의 최댓값만 추출 (MAX(LEVEL))
	- CONNECT_BY_ISLEAF 사용
	- stackoverflow
        - vo.la/e1bGTA
        - han.gl/dAGiA
	- thebook.io : vo.la/69qFqd
	- 최하위 노드면 1, 아니면 0 반환

-----------------------------
## 검색
- 패키지 이름 찾기/검색
	- ALL_SOURCE, TEXT LIKE, OWNER 이용
        ```SQL
        SELECT * FROM ALL_SOURCE
		WHERE TYPE='PACKAGE'
		AND TEXT LIKE '%OPINION%'
		AND OWNER='TEST'
        ```
		
		
- 패키지 이름 및 내용 찾기/검색 
  - ALL_SOURCE 이용 2 : vo.la/rj1MeJ
    ```SQL
    SELECT *
	FROM ALL_SOURCE
	WHERE 1=1
		AND TYPE IN ('FUNCTION', 'PROCEDURE', 'PACKAGE')
		AND UPPER(TEXT) LIKE '%주택수%'
	ORDER BY OWNER, NAME, TYPE, LINE;
    ```
	- OWNER : 소유자
	- NAME : 테이블 이름
	- 타입 : 함수, 프로시저, 패키지
	- TEXT : 내용
		
- 테이블명/칼럼명 검색/칼럼명 조회
	- crone.tistory.com/6
        ```SQL
        SELECT OWNER, TABLE_NAME, COLUMN_NAME
        FROM ALL_TAB_COLUMNS
        WHERE 1=1
            AND UPPER(TABLE_NAME) LIKE '%TEST%'
            AND UPPER(COLUMN_NAME) LIKE '%TEST1%'
        ORDER BY OWNER, TABLE_NAME, COLUMN_NAME
        ;
        ```

- 코멘트(주석) 검색
	- gent.tistory.com/206
	- 테이블 코멘트 : ALL_TAB_COMMENTS
	- 칼럼 코멘트 : ALL_COL_COMMENTS
        ```SQL
        SELECT DISTINCT *
        FROM ALL_COL_COMMENTS
        WHERE 1=1
            AND OWNER LIKE 'TEST'
            AND TABLE_NAME LIKE '%TEST1%'
            AND COMMENTS LIKE '%조사%'
        ;
        ```


----------------------------------------------------------------

## 프로시저
- 프로시저 실행
    - `EXEC TESTPRC`;
    - `EXEC TESTPRC(:P1, :P2)`;
    - EXEC 붙여 실행하기
    - 매개변수에 콜론 붙이면 매개 변수 대화상자 띄움
    - 실행 시간이 길 수 있으니 차분하게 기다리자 (10~20분)
	
- 프로시저 보기/수정하기
    - Schema Browser에서 BODY 등 선택 → 수정 후 저장 → 컴파일
	- 혹시나 그냥 패키지 선택했을 때 PROCEDURE CALL_INS_INFO; 이렇게만 나온다면
	  트리 펼쳐서 Body 살펴보고 해당 프로시저 있으면 더블클릭
	  
- 프로시저 컴파일&커밋 후 ORA-04068(패키지 기존 상태 버려짐), ORA-04065(실행 불가) 오류
	- 잠시 기다려보기
	
- 패키지 / 프로시저 만들기
	- gent.tistory.com/351
	- 커서 출력하기
		- 예-1줄 : `EXEC TESTPRC(2020950030, 4718, :CUR);` 이렇게 있으면
		- F9 누르고 :CUR 변수 선택할 때 Type에서 'Cursor' 선택 (vicki.tistory.com/959, dexcore.tistory.com/418)
		- 예-익명 프로시저
            ```SQL
            DECLARE
				P_TEST_CUR SYS_REFCURSOR;
			BEGIN
			    TESTPRC(2020950030, 4718, :P_TEST_CUR);
			END;
            ```
			- 얘도 1줄 실행문과 똑같다. 커서 앞에 콜론 붙여서 커서 타입 지정할 수 있도록 하기.
		- 익명 프로시저에 매개변수를 넣고 싶으면
            ```SQL
            DECLARE
				P_OLD_SEQ NUMBER := :P_OLD_SEQ_INPUT;
				P_NEW_SEQ NUMBER := :P_NEW_SEQ_INPUT;
            ```
			이렇게 DECLARE에 넣기
        - 동적 쿼리 출력하기
            ```SQL
            OPEN P_CUR FOR V_SQL;
            ```

- 패키지 안에서 패키지 내 프로시저/함수 실행
	- wakestand.tistory.com/173
	- 프로시저 예
        ```SQL
		BEGIN
			PACKAGE_TEST.PROC_TEST('홍길동', 50);
		END;
        ```
	- 함수 예 : `SELECT PACKAGE_TEST.examFunc('남') FROM DUAL`;

- 프로시저 DBMS_OUTPUT.PUT_LINE에서 여러 문자열 출력
	- `DBMS_OUTPUT.PUT_LINE("V_GRADES : " || V_GRADES);`

- 프로시저 실행 시 그리드로 결과 받기
    - 커서를 매개변수 설정, 타입은 SYS_REFCURSOR
    - 예 : 
        ```SQL
        CREATE OR REPLACE PROCEDURE TEST.TESTPRC (
            P_CUR OUT SYS_REFCURSOR
            , P_PARAM IN VARCHAR2
        )
        ...

        OPEN P_CUR FOR
            ...;

        -- 실행 시 바인드 변수 활용
        EXEC TEST.TESTPRC(:P_CUR, '11110');
        ```

		
-----------------------------	
## 스케줄
- Scheduler Job 등록
	- Schema Browser에서 Sched. Jobs 찾아 클릭
	- 왼쪽 탐색 창에서 오른쪽 마우스 클릭 -> Create -> Scheduler Job
	- 보통은 아래처럼 설정(기본값)
		- Basic Info
			- Job Class는 DEFAULT_JOB_CLASS
			- 오른쪽에 Enabled 체크
			- Comments에 쓰고 싶은 말 쓰기
			- Logging Level은 OFF
			- 나머지는 그대로
		- Schedule Info
            - 'Specify Schedule Info' 체크
			- Repeat Interval
                - 1초마다 돌리기 : `FREQ=SECONDLY`
                - 5분마다 돌리기 : `FREQ=MINUTELY; INTERVAL=5`
				- 매일 돌리기 : `FREQ=DAILY; BYHOUR=6; BYMINUTE=0; BYSECOND=0;`
				- 매주 돌리기 : `FREQ=WEEKLY; BYDAY=FRI; BYHOUR=20; BYMINUTE=0; BYSECOND=0;`
				- 보통 시간은 아침 6시로 한다. 사실 사람 없는 시간이면 언제든지 좋다.
		- Program Info
			- Program Type 
				- PLSQL_BLOCK : PLSQL_BLOCK으로 설정해야 SQL문을 작성할 수 있다
				- Use Predefined Program / Stored Procedure : 혹시 프로시저/패키지를 돌리고 싶다면 이거 둘 중에 하나 사용하면 될듯(나중에 검색해보기)
	- 수정 : 수정을 원하는 job에서 마우스 오른쪽 클릭 > Alter

- 외부 테이블 가져오기 : @ 사용
	- 예: 
        ```SQL
        LEFT OUTER JOIN GJ_INSA.V_IINSA_TOT@RAC INSA
            ON INSA.EMPNO = LI.ID
        ```
-----------------------------
## 날짜
- 키워드 : 날짜 계산, 시간 계산, 시각 계산, 날짜계산, 시간계산, 시각계산
- 날짜 계산
	- coding-factory.tistory.com/440 (아카이브 : archive.ph/OMcgd)

- 날짜(밀리초까지 표시)
    - `SELECT SYSTIMESTAMP FROM DUAL;`
    - 날짜/시간 표시 양식 변경하기
        예 : `SELECT TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD HH:MI:SS:FF6') FROM DUAL;`

- 날짜(요일 표시)
    - `TO_CHAR(SYSDATE, 'DAY')` 처럼 포맷으로 사용
    - `DAY` : 월요일
    - `DY` : 월
    - `D` : 2 (일~토 = 1~7)

- 날짜/시간 차이 계산
    - gent.tistory.com/405
    - 날짜 :
        ```SQL
        SELECT TO_DATE('2021-05-08', 'YYYY-MM-DD') - TO_DATE('2021-05-01', 'YYYY-MM-DD') FROM DUAL;
        ```
    - 시간
        ```SQL
        SELECT ROUND((TO_DATE('15:00','HH24:MI') - TO_DATE('13:00', 'HH24:MI')) * 24, 2) FROM DUAL;
        ```
- +1년씩 증가
    - han.gl/CGDch
    ```SQL
    SELECT
        ADD_MONTHS(DATE'2023-01-01', (LEVEL-1)*12) AS YR_ADD
    FROM DUAL
    CONNECT BY LEVEL <= 5
    ```
- 두 날짜 사이 년도들 구하기
    - han.gl/Eonbb (archive.is/Mf6Jo) - Burleson Consulting
    ```SQL
    SELECT
        TO_CHAR(DATE'2022-01-01', 'YYYY') - 1 + LEVEL AS YEAR
    FROM DUAL
    CONNECT BY LEVEL <= MONTHS_BETWEEN(TRUNC(DATE'2027-01-01', 'YYYY'), TRUNC(DATE'2022-04-01', 'YYYY'))/12 + 1
    ;
    ```

- 달의 첫 날 구하기
    - bangyee.tistory.com/9 (archive.is/PQKYv)
    - 예
        ```sql
        -- 달의 첫 날 구하기 (M월 1일)
        TRUNC(SYSDATE, 'MM')

        -- 1월 1일 구하기
        TRUNC(SYSDATE, 'YYYY')
        ```
- 1년이 며칠인지 구하기
    - han.gl/shmAk (stackoverflow.com/questions/59970982)
    ```SQL
    SELECT
        TRUNC(SYSDATE, 'YEAR') AS ST_DT
        , TRUNC(SYSDATE, 'YEAR') + INTERVAL '12'MONTH AS END_DT
        , (TRUNC(SYSDATE, 'YEAR') + INTERVAL '12'MONTH) - (TRUNC(SYSDATE, 'YEAR')) AS DAYS
    FROM DUAL
    ;
    ```


-----------------------------
## 파티션
- 파티션 관리하기
    - vo.la/lKtZKT
    - 관련 테이블
        ```SQL
        SELECT * FROM DBA_TAB_PARTITIONS;
        SELECT * FROM DBA_IND_PARTITIONS;
        SELECT * FROM DBA_PART_TABLES;
        SELECT * FROM DBA_PART_INDEXES;
        ```
    - 인터벌 파티셔닝(interval partitioning) : 파티션 생성 시 옵션. 특정 규칙을 준수하면 자동으로 파티션 생성해주는 데 이름 짓는 규칙까지는 설정 불가인 듯.
        - vo.la/M5eNNp (archive.is/3Q4Ut)

-----------------------------
## 오류
- 오류: 테이블이 변경되어 트리거/함수 가 볼 수 없습니다 (table OOOO is mutating, trigger/function may not see it)
    - zorba91.tistory.com/214
    - 원인 : 업데이트되는 중인 테이블을 참조하는 함수이기 때문
    - 해결법 : 이렇게 쿼리 짜지 말 것!
        - 그래도 짜야 한다면 함수 is 부분에 PRAGMA AUTONOMOUS_TRANSACTIONS; 추가
        - 부작용으로 LOGGING 테이블이 자율 트랜잭션으로 채워질 수도 있다고.

- 오류: ORA-30926 원본 테이블의 고정 행 집합을 가져올 수 없습니다
	- goddaehee.tistory.com/70 (archive.is/DR77A)
	- shyoung.tistory.com/72 (archive.is/FXr8Y)
	- MERGE INTO 실행 시 중복된 항목 있을 때 오류 발생
	
- 오류: ORA-01476 제수가 0입니다
	- dev4u.tistory.com/211
	- 분모가 0이어서 발생
	- 이렇게 수정하기 → `SELECT NVL(분자, DECODE(분모, 0, NULL, 분모), 0) FROM 테이블;`
	
- 오류: ORA-14400 삽입된 분할 영역 키와 매핑되는 분할 영역이 없음
	- 오류가 발생한 테이블은 파티션 테이블이다. (vo.la/Dj5okE, archive.is/k7Tdz)
	- 파티션을 생성해야 한다
        ```SQL
        ALTER TABLE TEST.TEST1 ADD PARTITION P2022 VALUES ('2022');
        ```
		- 범위를 정하고 싶다면 VALUES LESS THAN (~) 사용 : 이때 LESS THAN 옆에 넣은 값은 HIGHVALUE가 된다.
		- jack-of-all-trades.tistory.com/81 (archive.is/38zX7)
		- gent.tistory.com/138
    - 프로시저 안에 파티션 생성 코드 넣기
        - vo.la/qvOVXQ
        - EXECUTE IMMEDIATE 이용
        - `EXECUTE IMMEDIATE ALTER TABLE TEST1 ADD PARTITION P2022 VALUES ('2022')`
        - 세미콜론 없어도 됨
		
- 오류: ORA-54017 UPDATE 작업은 가상 열에서 허용되지 않습니다.
	- 가상 칼럼은 업데이트 불가 (Describe Object > Columns 탭에서 Virtual에 체크되었는지 확인)
	- vo.la/ln1qEi (archive.is/9etjd)
	- 가상 칼럼 특징
		- 표현식 등에 의해 정의
		- DB에 저장되지 않음 (실행 중 계산)
		- UPDATE 불가
		- UPDATE, DELETE절의 WHERE에 나타날 수 있지만 변경 불가

- 오류: ORA-08002 시퀀스 SEQ.CURRVAL은 이 세션에서는 정의되어 있지 않습니다
    - sanghoo.tistory.com/42
    - NEXTVAL 호출 후 CURRVAL 호출

- 오류: ORA-02012 키워드 USING을 지정해 주십시오
    - 동적 쿼리 사용 시 발생할 수 있음
    - 동적 쿼리에 사용할 문자열은 여러 개 붙일 경우 항상 뒤에 공백 삽입하기
    - 예 : 
		```SQL
        V_SQL VARCHAR2(4000);
        V_SQL := 'MERGE INTO TEST.TEST1 TT ';
        V_SQL := V_SQL||'USING ( ';
        ```

- 오류: ORA-02291 무결성 제약 조건이 위배되었습니다. 부모 키가 없습니다
    - 자식 테이블에 있는 데이터가 부모 테이블에 없는 경우
    - 자식 테이블에 있는 데이터가 부모 테이블에 있으면 안 되는 경우

- 오류: ORA-01403 No data found. 데이터를 찾을 수 없습니다
    - 해결법: yulsfamily.tistory.com/307 (archive.is)
-----------------------------
## 튜닝
- Quest SQL Optimizer 이용
    - vo.la/KqN3ln (archive.is/5Ol5X)


-----------------------------
## PL/SQL
- PL/SQL에서 결과 보기
    - 커서 사용하고 BEGIN~END 구간에서 커서를 바인드 변수로 처리한다
    - 그 다음 실행할 때 CURSOR, OUT으로 설정
    - 예
        ```SQL
        DECLARE
            V_YEAR VARCHAR(4);
            V_MONTH VARCHAR2(2);
            V_CUR SYS_REFCURSOR;
            
        BEGIN
            V_YEAR := '2022';
            V_MONTH := '09';
            

            OPEN :V_CUR FOR
                SELECT *
                FROM (
                SELECT 1 FROM DUAL
                );
        END;
        ```
    - 참고
        - vo.la/GHcqaE (archive.is/Yw4he)
        - blog.naver.com/cestlavie_01/221080931797
  
- PL/SQL에서 소수점 출력 시 정수 부분도 나오게 하기
    - 예 : 
        ```SQL
        DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_YEAR_AVG_APART, '9990D99999'));
        ```
    - TO_CHAR 이용, 포맷 지정
    - han.gl/UAUpW (archive.is/E8Xx8)

- 배열
    - 중첩 배열
        - 동적 배열이다. 크기 제한 X
        - 예 (han.gl/GujRa) (archive.is/tk6Q2)
            ```sql
            -- 배열 연습
            DECLARE
                -- 타입 선언
                TYPE NEST IS TABLE OF NUMBER;   -- 중첩 배열
                P_CUR SYS_REFCURSOR;
                
                -- 변수 선언 및 초기화
                N1 NEST := NEST();
            BEGIN
                FOR I IN 1..9
                LOOP
                    N1.EXTEND;
                    N1(N1.LAST) := I;
                END LOOP;
                
                FOR I IN 1..N1.COUNT
                LOOP
                    DBMS_OUTPUT.PUT_LINE(N1(I));
                END LOOP;   

            END;
            ```
        - 참고
            - goddaehee.tistory.com/263

    - 연관 배열(associative array) (key, value 활용 가능)
        - han.gl/CSODM (stackoverflow.com/questions/27175030)
        - vo.la/hqaAe (morningcoding.tistory.com, archive.is/HXf5M)

    - 레코드 배열
        - 구조체처럼 활용 가능!
        - 참고
            - vo.la/Y2SS9 (stackoverflow.com/questions/9155742)
            - han.gl/XlOtJe (blogs.oracle.com)
        - 예시
            ```SQL
            DECLARE
                TYPE RECTYPE IS RECORD (
                    REG VARCHAR2(5)
                    , EUB VARCHAR2(5)
                    , SREG VARCHAR2(5)
                    , SEUB VARCHAR2(5)
                );
                
                TYPE RECTBL IS TABLE OF RECTYPE INDEX BY PLS_INTEGER;
                TBL_IDX PLS_INTEGER;
                REGREC RECTBL;
                
            BEGIN
                TBL_IDX := REGREC.FIRST;
                REGREC(1).REG := '11111';
                REGREC(1).EUB := '22222';
                REGREC(1).SREG := '33333';
                REGREC(1).SEUB := '44444';
                TBL_IDX := REGREC.NEXT(TBL_IDX);
                
                
                TBL_IDX := REGREC.FIRST;
                LOOP
                    EXIT WHEN TBL_IDX IS NULL;
                    DBMS_OUTPUT.PUT_LINE('REGREC('||TO_CHAR(TBL_IDX)||').REG: '||REGREC(TBL_IDX).REG);
                    

                    TBL_IDX := REGREC.NEXT(TBL_IDX);
                END LOOP;


            END;
            ```

- 레코드
    - 참고: goddaehee.tistory.com/264 (archive.is/k5ZJn)
    ```sql
    TYPE RECORD1 IS RECORD (
        DEPTNO NUMBER
        , DNAME VARCHAR2(14)
        , LOC VARCHAR2(13)
    )

    -- FOR~SELECT로 한번에 테이블 정보 불러오기 가능
    FOR C2 IN (
        SELECT DEPTNO, DNAME, LOC
        FROM DEPT
    )
    LOOP
        DBMS_OUTPUT.PUT_LINE(...)
    END LOOP;
    
    ```

- One time only procedure
    - 패키지 내 함수, 프로시저가 최초로 호출될 때 딱 한번 사용됨
    - 참고
        - han.gl/gBaDl (ojc.asia, archive.is/Opl1x)
        - han.gl/dXQWX (blog.naver.com/imf4, archive.is/LhmZs)

- 매개 변수가 NULL이면 없는 걸로 취급하기
    - ```SQL
        SELECT *
        FROM EMP
        WHERE (DEPARTMENT = :P1 OR :P1 IS NULL)
        ```
    - 참고
        - stackoverflow.com/questions/45881633
        - stackoverflow.com/questions/17850726
    - IS NULL/IS NOT NULL 사용 시 발생하는 full scan 방지하기
        - han.gl/nDSGdj
        - han.gl/XoEjMt (blog.naver.com/cjsong, archive.is/F9IU4)
            - IS NOT NULL 조회 개선
                - CHAR/VARCHAR2
                    ```SQL
                    SELECT * FROM NULL_T WHERE C3 > ' '
                    SELECT * FROM NULL_T WHERE C3 > CHR(0);
                    ```
                - DATE: 존재할 수 없는 날짜 이용
                    ```SQL
                    SELECT * FROM NOT_NULL_T WHERE C1 > TO_DATE('19000101', 'YYYYMMDD')
                    ```
                - NUMBER: 0 이용
                    ```SQL
                    SELECT * FROM C1>=0 OR C1<0;
                    ```
        - 인덱스 생성
            ```SQL
            CREATE INDEX MYTABLE_IDX
            ON MYTABLE(X, ' ');
            ```
        - 아니면 NULL 대신 NaN을 넣고 인덱스를 만들면 된다고 한다.
            - 예 : `SELECT BINARY_FLOAT_NAN FROM DUAL;`




-----------------------------
## Toad
- 글꼴 변경
    - View → Toad Options → Editor → Font and Styling
    - 여기서 글꼴 변경

- Data Grid 글꼴 바꾸기
    - Options-Data Grids-Visual-Styles-Edit-Simple-Font 

- Explain Plan
    - 쿼리 결과 예상
    - 블록 씌우고 Ctrl+E
	- Explain Plan 보는 법 + Plan Table 변경 (toad.co.kr)
		- vo.la/rJ86hL
		- View > Toad Options > Oracle > General > Explain Plan 메뉴
		- Table 옆에 기본값으로 TOAD_PLAN_TABLE이라고 되어 있음.
		- 옆의 3개 점 있는 버튼 클릭
		- Do you want to keep it as your selection? > NO
		- Search For Plan Table > 원하는 테이블 클릭
		- 오라클 기본값은 `SYS.PLAN_TABLE$`이다. 사실 TOAD든 SYS든 똑같다.
	- 트리 말고 콘솔 형태로 보기 (blog.toadworld.com)
		- vo.la/L0AyL1
		- Explain Plan 결과창 우클릭 > Display Mode > DBMS_XPlan
		- 모든 정보를 보고 싶으면 Explain Plan 결과창 우클릭 > DBMS_XPlan Format
			- Level = Advanced
			- Stats = Allstats
			- Fine Grained Control = 모두 Default

- Schema Browser에서 칼럼 이름 찾기
	- Ctrl+F 후에 'Filter With' 옵션을 선택하면 partial anywhere 옵션을 선택할 수 있어 편리하게 검색 가능



- Toad for oracle - Describe Object에서 테이블 데이터 새로고침
	- 메뉴 중 'Grants' 아래에 보면 휘어진 화살표(Refresh Data) 있는데 그걸 누르면 된다.
	
- Toad for oracle 작업 예약 (Scheduler Job)
	- Schema browser에서 오른쪽 콤보 박스 → Sched. Jobs 메뉴 찾아 클릭

- Toad 가운데 선(중앙선) 삭제
    - View > Toad Options > Editor > Display > Edge Mode
    - 여기서 None 선택

- Toad 메뉴 천천히 사라지는 현상 해결
    - View > Toad Options > Toolbars/Menus > Toolbars > Visual Style > Standard로 변경

- Import Table Data
    - Database > Import > Import Table Data
    - 함수가 들어가면 E4018 Invalid use of operator 오류 출력하므로 꼭 값만 있는 엑셀 파일 활용 (없으면 값으로 복사 후 새로 만들기)
    - Preview File and Define Fields
        - Map fields by matching field names: 칼럼 이름이 엑셀 1번째 줄에 있고 순서도 맞음
        - Map fields sequentially: 칼럼 이름은 없고 순서만 맞음

-----------------------------
## SQL Developer
- 데이터 임포트/익스포트(import/export)
    - tsv 및 대용량 데이터 임포트 가능
        - toad에서는 120MB 이상 파일은 읽다가 메모리 오류가 발생하는데 SQL Developer는 발생 안 함
    - 테이블 우클릭 > '데이터 임포트'

-----------------------------
## 기타
 
- TIMESTAMP
    - `AS OF TIMESTAMP TO_TIMESTAMP('20220104 1800','YYYYMMDD HH24MI')`
    - REB DB의 경우 보통 15시간 전 데이터까지는 보관하는 듯

- OUTER JOIN 꼭 명시


		

- 다른 컬럼과 원래 DB 함께 출력
    ```SQL
    SELECT '' AS DT, A.*
        FROM BBS_DOC A
        WHERE BBS_ID='B0005970' AND DOC_SUBJECT LIKE '(ICT%';
    ```
    - 테이블을 A 등 이름 설정하고 SELECT문에 A.*으로 놓고 출력

- 데이터 중복 검증
    - SELECT에 COUNT() 쓰고,
    - GROUP BY로 묶어 중복이 몇 개가 나오는지 보기
    - 아니면 COUNT(*) OVER(PARTITION BY BM.SEQ) AS BM_SEQ_COUNT처럼 COUNT-OVER-PARTITION BY 쓰기
        - 이거 쓰려면 쿼리 전체를 괄호로 묶고 WHERE 조건은 밖으로 빼기 (kwomy.tistory.com/76)

- 테이블 정보 보기 : Describe Objects (단축키 F4)
    - 창 따로 띄우기 가능!
    
- 문자열 붙이기
    - || 기호 사용하기
    

- 최상위 값 추출
    - CONNECT_BY_ROOT, CONNECT BY PRIOR 사용
    - 참고 : 우선순위는 CONNECT BY > WHERE이다. 그래서 WITH절로 먼저 필요한 부분만 빼내야 한다.
        CONNECT BY부터 실행하고 WHERE을 나중에 실행하기 때문에 

- 그룹의 개수 세기
    - OVER(PARTITON BY) 사용하기
        - 예 : `COUNT(EXPOS.DONG_NM) OVER(PARTITION BY TEST.DONG_NM) AS TEST_DONG_NM`
        - GROUP BY 필요 없음
        
- 하나의 열의 원소 개수 세기
    - 중복 제거한 원소 세기 :` COUNT(DISTINCT TEST.DONG_NM) OVER() AS DONG_COUNT`
    
- 시퀀스를 쓰려면 원래 쿼리를 서브쿼리로 묶고 바깥에 작성
    - 출처 : HOENGSEONG_WATER.sql
        ```SQL
        SELECT
            TESTSEQ.NEXTVAL AS SEQ
            , HST.* 
        FROM ( ~ ) HST
        ```

- INSERT INTO ~ SELECT
    - WITH절 포함된 서브쿼리 형태로 넣을 때 : 꼭 WITH 앞에 쓰기!
    - INSERT INTO ~ WITH 순서로

- ALTER TABLE
    - MODIFY
        - 여러 칼럼 타입 한번에 변경 :
            ```SQL
            ALTER TABLE TEST.TEST1
            MODIFY(
                T1 NUMBER(20)
                , T2 NUMBER(20)) 
            ;
            ```

    - DROP
        - 여러 칼럼 한번에 삭제 :
            ```SQL
            ALTER TABLE TEST.TEST1
            DROP (T1, T2)
            ;
            ``` 

    - ADD
        - 여러 칼럼 한번에 추가
            ```SQL
            ADD (
                T1 NUMBER(20)
                , T2 NUMBER(20)
            )
            ;
            ```

	- RENAME
		- 칼럼명 변경
            ```SQL
            ALTER TABLE TEST.T1
			RENAME COLUMN SBUN1 TO BUN1
            ```
			- 여러 칼럼명 동시 변경은 오라클 구조상 불가능

- DROP TABLE
    - 여러 테이블 한번에 삭제 : PL/SQL 이용
    - 예
        ```SQL
        BEGIN
            FOR TBL_LIST IN (
                SELECT DISTINCT TABLE_NAME
                FROM ALL_TAB_COLUMNS
                WHERE 1=1
                    AND OWNER = 'TEST'
                    AND UPPER(TABLE_NAME) LIKE 'TMP_%ADEL'
            )
            LOOP
                EXECUTE IMMEDIATE 'DROP TABLE T1.'||TBL_LIST.TABLE_NAME;
            END LOOP;
        END;
        ```
        - 출처 : han.gl/wNriO
	
- 칼럼 타입 변경
	- 예 : VARCHAR2 → TO_NUMBER
		- ADD → UPDATE → DROP 순으로 진행
		- UPDATE는 데이터 중복 방지를 위해 WHERE 조건으로 모든 칼럼을 설정하기



	
- Toad에서 PL/SQL 반환값 보기
	- 하단 메뉴에서 DBMS Output(disabled) 찾아 클릭
	- DBMS Output 탭 아래 메뉴에 잘 보면 빨간색 점이 있는데 그거 클릭해서 녹색으로 만들기 (Turn Output On)
	- 왼쪽에 새로고침에 번개 모양 달린 거 누르면 결과 자동으로 출력 (Automatically poll outut after execution)



- (HUGECLOB)으로 표시되는 항목 바로 보기
	- Toad : View > Toad Options > Data Grids > Data 탭에서 Preview CLOB and LONG Data 체크
	- SQL : SELECT DBMS_LOB.SUBSTR(컬럼, 500) FROM TABLE
	
- SQL문 중간에 슬래쉬(/) 넣기
	- 이러면 다음에 파일 열 때 Split할거냐고 물어본다. '예' 누르면 파일이 분할된다. 조심!
	
- '패키지 보내주세요'의 뜻 : 패키지 다 만들었으면 어떻게 실행하는지 명령어를 보내 달라.
	- 예 : EXEC TEST.TEST1(:P_DONG_INFO_SEQ, :P_CUR);
	
- 제약 조건 설정
	- 종류 : all-record.tistory.com/151
	- 사용 방법 : vo.la/SOvRF
	- 예 : ALTER TABLE TEST.TEST1 ADD UNIQUE(HOUSE_MANAGE_NO)
		- 칼럼명에 따옴표 안 쓰는 거 주의!

- 인덱스 확인
	- 인덱스 생성 : gent.tistory.com/417
	- 어떤 칼럼에 어떤 인덱스가 들어가는지 확인 (gent.tistory.com/203)
		SELECT
			A.TABLE_NAME
			, A.INDEX_NAME
			, A.COLUMN_NAME
		FROM ALL_IND_COLUMNS A
		WHERE 1=1
			AND A.TABLE_NAME LIKE '%TEST1'
		ORDER BY A.INDEX_NAME, A.COLUMN_POSITION
		;
	- 해당 인덱스에 대한 정보를 구체적으로 확인 (coding-factory.tistory.com/419)
		SELECT *
		FROM USER_INDEXES
		WHERE TABLE_NAME LIKE '%TEST1%'
		;


- 테이블 백업
	- 백업 테이블 만들고 모든 데이터 복사
		CREATE TABLE TEST_BACKUP AS
			SELECT * FROM TEST

- 결과가 너무 많아 일부만 출력하려면?
	- 조건 이용 : WHERE ROWNUM <= 100

- 테이블 이름 앞에 V_ 붙이면 뷰 형태가 된다.
	- 예 : V_TEST → TEST 테이블을 뷰로 보기
	
- REGEXP_LIKE 사용하지 말 것!
	- 성능 차이가 너무 크다...
	- okky.kr/article/523333
	- 차라리 그냥 LIKE를 쓰자

- LIKE 대신 INSTR('~~', '문자열') > 0으로
	- dabok407.tistory.com/18
	- NULL 무시 여부 꼭 알아두기
        - LIKE는 NULL을 만나면 그대로 건너뛴다.
        - 예
        ```SQL
        -- T1 = NULL일 때
        CASE WHEN INSTR(T1, '테스트', 1,1)>0 THEN 0 ELSE 1 END -- 이렇게 하면 1이 나온다.
        CASE WHEN T1 NOT LIKE '%테스트%' THEN 1 ELSE 0 END -- 이렇게 하면 1이 안 나온다!!
        ```


- MERGE INTO 팁
	- MERGE INTO는 있으면 UPDATE, 없으면 INSERT를 한번에 수행한다
	- offbyone.tistory.com/253
	- mine-it-record.tistory.com/261
	- wakestand.tistory.com/121
	- INSERT가 안 된다!
		- vo.la/IV3LUb
	- MERGE INTO에서 USING 안의 구문은 UPDATE 또는 INSERT할 결과물이다
		- vo.la/JynwGh (stackoverflow.com/questions/31827504/oracle-merge-wont-insert-only-update)
    - WHEN NOT MATCHED THEN UPDATE NULL - 값이 없을 때 NULL로 바꾸고 싶을 때
        - UNION ALL과 NOT EXISTS를 이용
        - 참고: flowlog.tistory.com/104 (archive.is/bI2uW)
	
- 중복 제거
    - 키워드: 중복 항목 제거, 중복 제거, 중복제거, duplicate
	- zorba91.tistory.com/202 (archive.is/qiywy)
	- 1번째 방법 추천
        ```SQL
        DELETE FROM TEST.TEST1
		WHERE ROWID IN (
			SELECT ROWID
			FROM (
				SELECT * FROM (
					SELECT ROW_NUMBER() OVER(PARTITION BY T1) AS NUM
					FROM TEST.TEST1
				)
				WHERE NUM > 1
			)
		)
        ```

	- 참고 : EXISTS가 효과가 없을 때에는 한 테이블에 중복된 값이 여러 개 있을 때이다 (vo.la/mlBB4O)
		예 : 이름      점수
			 홍길동    85
			 홍길동    85			 
			 홍길동    85		
		이렇게 같은 항목이 여러 개가 있으면 EXISTS를 써도 저 3개가 다 나온다. 셋 다 존재하기 때문
		- 그럼 언제 효과가 있냐?? 두 테이블에 동일한 값이 하나만 있을 때.
		예2 : 테이블 A
				이름     점수
			    홍길동    85
				전우치    90
			  테이블 B
			    이름     점수
				홍길동    85
				임꺽정    100
	- 한 칼럼만 중복될 때
		예: SEQ		TYPE	LENGTH(DATA)	
			1		 1			10
			2		 3			20
			3		 4			10
		`COUNT(*) OVER(PARTITION BY, ORDER BY)`를 적절하게 사용
		- 참고 : c11.kr/10pls (blogs.oracle.com/sql/post/how-to-find-and-delete-duplicate-rows-with-sql)
    - ROWNUM=1을 쓰면 풀스캔을 시도할 수도 있으므로 속도 저하 가능성 있음
        - ROWNUM <= 1로 범위 지정하기
        - okky.kr/article/465355
- EXISTS
    - okky.kr/article/757590 (archive.is/7uAgj)
    - EXISTS : 1건을 만나면 끝난다 (100번, 1000번 구매했는지 알 필요가 없음)
    - IN : A라는 상품을 10번 샀으면 10건의 데이터를 모두 찾아야 끝난다.
    - 중복데이터가 많으면 EXISTS가 좋다
    - 찾으려는 데이터가 1건만 있다면 성능은 동일

- 소수점 자리수 고정
	- vo.la/5X3sPW
	- 예 : 2자리로 고정 : TO_CHAR(57, 'FM90.00')
	- FM : Fill Mode. 결과값의 좌우에 있는 공백 제거
	  9 : 해당 자리에 해당되는 숫자 있으면 그 숫자 표시, 없으면 공백
	  0 : 해당 자리에 해당되는 숫자 있으면 그 숫자 표시, 없으면 0

    - 참고
        - han.gl/gPWzlP
	  

- 덤프(.dmp) 파일 이관(import, export) 작업
	- grandj.tistory.com/83
	- vo.la/gWplJ2
	- 오라클 DB 백업과 복구전략 : tennesseewaltz.tistory.com/239
	- 덤프 설명 : heavening.tistory.com/31
	- 덤프하는 방법 (exp, expdp 툴 사용) : deftkang.tistory.com/144
	
- BLOB, CLOB 발음
	- BLOB(Binary Large OBject) : 비랍
	- CLOB(Character Large OBject) : 씨랍
	- 참고 : vo.la/ynEfJT (아카이브: archive.is/MpjkD)

- DBMS_SCHEDULER
	- Scheduler Jobs의 repeat interval같은 날짜 형식
	- hoing.io/archives/153
    
- Toad에서 원하는 부분 블록 씌우기
	- 해당 쿼리로 커서 이동 후 Ctrl+H
	
- LIKE 사용 시 특수문자도 검색
	- `LIKE 'M$_%' ESCAPE '$'`
	- ESCAPE로 사용할 아무 기호나 넣고 끝에 ESCAPE 명시
	- vo.la/HpUqOW

- 연도 표시 : 2013년~현재까지
    ```SQL
    SELECT
		TO_CHAR(SYSDATE, 'YYYY') - (LEVEL-1)  AS YEAR
	FROM DUAL 
	CONNECT BY LEVEL <= ((TO_CHAR(SYSDATE, 'YYYY') ) - 2012)
	ORDER BY YEAR DESC;
    ```


- PIVOT, UNPIVOT
	- PIVOT
		- vo.la/BXlcum (dejavuhyo.github.io/posts/oracle-pivot)
		- wyatt37.tistory.com/48 (아카이브 archive.is/hPVC0)
			- 예: `PIVOT( MAX(SALE) FOR SEASON IN ('봄', '여름', '가을', '겨울') )`
			- SALE의 최댓값을 (MAX, COUNT, SUM 종류의 함수만 사용 가능) SEASON에 따라 구분하는데
			- 이 SEASON 안의 봄, 여름, 가을, 겨울에 따라서 SALE을 구분한다.
			- 즉, IN 안의 값은 FOR에 적힌 칼럼에 다 있어야 한다.
        - vo.la/863fF (kutar37.tistory.com, archive.is/m3fu4)
            - 문자열로만 이루어진 값은 MAX 사용
            - 예: `MAX(LOC) FOR DNAME IN ('ACCOUNTING' AS ACCOUNTING, ...)`
        - vo.la/PT277 (velog.io/@kada, archive.is/EBjJR)
            - PIVOT 구성 : FOR 피벗할 칼럼 IN (항목1, 항목2...)
            - IN에는 상수만 가능 (서브쿼리 불가, 칼럼명으로 칼럼 값 불러오기 불가)
	- UNPIVOT
		- vo.la/89QVwN (dejavuhyo.github.io/posts/oracle-unpivot)
    - 주의 : PIVOT, UNPIVOT은 데이터가 대량일 경우 실행 시간이 오래 걸림
    - PIVOT XML
        - gent.tistory.com/336
        - IN 칼럼 동적으로 활용 가능. 즉 PIVOT만 사용하면 IN에 칼럼명을 직접 작성해야 했고 변경도 불가능한데 PIVOT XML은 그걸 가능하게 만든다!

- 동적 쿼리 (Dynamic SQL) 작성하기
	- 쿼리 앞에 SQLSTR := SQLSTR|| 붙이기
		- Notepad++ 활용
		- Replace(Ctrl+H)에서 '정규표현식' 체크
		- 찾을 내용 : 앞에 붙이려면 ^, 뒤에 붙이려면 $ 입력
		- 바꿀 내용 : 그냥 바꾸고 싶은 내용 입력
		- vo.la/Pwjmxe
		
	- 동적 쿼리 오류 시 메시지 보기
        ```SQL
        DBMS_OUTPUT.PUT_LINE(
			'SQLERRM : ' || SQLERRM || CHR(13)||CHR(10) ||
			'FORMAT_CALL_STACK : ' || DBMS_UTILITY.FORMAT_CALL_STACK()|| CHR(13)||CHR(10) ||
			'FORMAT_ERROR_BACKTRACE : ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()|| CHR(13)||CHR(10) ||
			'FORMAT_ERROR_STACK : ' || DBMS_UTILITY.FORMAT_ERROR_STACK()|| CHR(13)||CHR(10)  ||
			'SQLSTR LEN : ' || LENGTH(SQLSTR)            
        );
        ```

        - `CHR(13), CHR(10) : \r\n`
        - LENGTH는 작동 안 될 수도 있음

    - 동적 쿼리 따옴표 처리 : `q['']`
        - www.gurubee.net/article/68887
   


		
- PL/SQL에서 VARCHAR2 최대 길이 = 32767
	- thebook.io/006696/part02/ch08/02/07/01
	
- 값이 따로따로 있는 2개 이상의 열을 하나로 합치기
	- vo.la/K9VI7q (아카이브 : archive.is/YtWNf)
	- 합치고 싶은 항목에 MAX 쓰기. 나머지 유지하려는 항목은 GROUP BY로 묶기.
	
- NULL, 숫자 있을 때 MAX 쓰면 숫자 값 출력
	- 쿼리 예시
        ```SQL
		SELECT MAX(TEST1) FROM
		(SELECT NULL AS TEST1 FROM DUAL
		UNION ALL
		SELECT 1 AS TEST1 FROM DUAL)
        ```
		
- Split - 특수문자로 구분하기
	- vo.la/1jDpEX
	- 예
        ```SQL
		REGEXP_SUBSTR(T1, '[^-]+', 1, 1) AS BUN1
        REGEXP_SUBSTR(T1, '[^-]+', 1, 2) AS BUN2
        ```
		
- 문자열 조회 - 테이블의 값과 비교
	- 예 : 220711 빈집 기본정보 자동 산정.sql
        ```SQL
        CASE WHEN EXISTS (SELECT SMALL_NM FROM TEST.TEST1 WHERE INSTR(ROOF1, SMALL_NM_THES) > 0
                AND REGEXP_LIKE(SMALL_NM, '테스트1|테스트2')) THEN 4
        ELSE
            CASE WHEN EXISTS (SELECT SMALL_NM FROM TEST.TEST1 WHERE INSTR(ROOF1, SMALL_NM_THES) > 0
                AND REGEXP_LIKE(SMALL_NM, '테스트1|테스트2')) THEN 1
            ELSE 2 END
        END AS INSTR_TEST_1
        ```

		
- 문자열 일부 마스킹
	- `REPLACE(ID, SUBSTR(ID, -3, 3), '***')`
	- 시작위치 -3 : 뒤에서 3번째 자리부터
	- 길이 3: 3글자
	
- 바인드 변수 (:P_VAR)에 여러 값 넣기?
	- 불가능
	- vo.la/dRf8mB

- WHERE절 안에 CASE WHEN 넣기 (WHERE CASE WHEN)
    - 예 : 문자열
        ```SQL
        AND TEST.TEST1 LIKE
                    (CASE WHEN (P_PARAM = '00000' OR P_PARAM IS NULL) THEN '%'
                        WHEN SUBSTR(P_PARAM, 3, 3) = '000' THEN SUBSTR(P_PARAM, 1, 2)||'%'
                    ELSE P_PARAM END)
        ```
- 2개의 테이블을 UNION ALL처럼 row로 합치는 게 아니라 column칼럼으로 합치기
    - vo.la/pFFKim
    - SREG 공통적인 SEQ같이 생긴 부분을 LEFT OUTER JOIN하여 합치기
    - SEQ로 활용할 칼럼이 없다면 `ROW_NUMBER() OVER(ORDER BY TEST)` 처럼 ROW_NUMBER 활용

- 백분율 구하기
    - `RATIO_TO_REPORT() OVER() 사용`
    - 이미 합계가 있는 상황에서 백분율을 추가하려고 하는 상황일 때 : 합계가 50%, 나머지 합 50% 총합 100%일 경우 → ROUND 결과에 200을 곱한다
    - 예 : 
        ```SQL
        ROUND(RATIO_TO_REPORT(T1_D.CNT_APT4_APT5+T1_A_SEDAE.CNT_APT1+T1_A_SEDAE.CNT_APT2+T1_A_SEDAE.CNT_APT3+T1_A_SEDAE.CNT_APT6) OVER(),2)*200||'%' AS "전체_비율"
        ```
    - gent.tistory.com/384


- CLOB에 4000byte 이상 문자열 넣기
    - 먼저 INSERT로 빈 문자열을 넣고, PL/SQL을 이용해 업데이트
    - 참고 : 220803 국정감사 대비용 - 통계관리자 - 등급별 공동주택 빈집 수_v0.2.sql
    - vo.la/3PI452 (archive.is/OWNwt)

- 데이터 타입의 종류
    - sksstar.tistory.com/72
  
- 칼럼명, 테이블명 길이/글자 수 알기
    - Toad : `ALL_TAB_COLUMNS` 테이블명 입력 후 F4 누르기(Describe Object)
    - sqlplus(오라클 콘솔) : `describe all_tab_columns` 실행
        - vo.la/b6zQam

- 여러 테이블 한번에 삭제 (DROP TABLES)
    - PL/SQL문 사용
    ```SQL
    BEGIN
        FOR REC IN (SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME LIKE 'TMP_SQL_CLOB_TBL_%')
        LOOP
            EXECUTE IMMEDIATE 'DROP TABLE '||REC.TABLE_NAME||' CASCADE CONSTRAINTS';
        END LOOP;
    END;
    ```
    - vo.la/80hbaZ   (archive.is/SxzMI)

- BETWEEN 사용법
    - `BETWEEN 1 AND 2` = `1 <= x <= 2`
    - gent.tistory.com/282

- 코멘트
    - 코멘트 추가 : `COMMENT ON COLUMN TEST.TEST1 IS '테스트';`
    - 코멘트 수정 : 추가와 동일
    - 코멘트 삭제 : 코멘트 내용을 ''으로 설정
    - 참고 : dev-huhu.tistory.com/57

- 테이블 칼럼 추가
    - gent.tistory.com/323
        ```SQL
        -- 칼럼 추가
        ALTER TABLE emp ADD email VARCHAR(25) DEFAULT '-' NOT NULL;

        -- 칼럼 삭제
        ALTER TABLE emp DROP COLUMN email;
        ```
- 테이블 칼럼 순서 변경
    - gent.tistory.com/323
        ```SQL
        -- 칼럼 숨김
        ALTER TABLE emp MODIFY job INVISIBLE;

        -- 칼럼 표시
        ALTER TABLE emp MODIFY job VISIBLE;
        ```

- 프로시저에서 테이블 있는지 확인
    - vo.la/6sSuXa
    - 먼저 `USER_TABLE`에서 테이블 이름 찾기
    - 있으면 DROP

- 칼럼 여러 개 비교
    - ALL 사용 : 여러 칼럼이 모두 동일한 값인지 비교 가능
        - NULL 무시
        - 예
            ```SQL
            CASE WHEN ((U_01 <> 0) AND (U_01 = ALL(U_02,U_03,U_04,U_05,U_06,U_07,U_08,U_09,U_10,U_11,U_12))) THEN 1
            ELSE 0 END AS U_ALL_SAME_YN  
            ```
        - 참고
            - gent.tistory.com/287
            - vo.la/a7jGpg
    - COALESCE : 왼쪽에 쓰인 값부터 출력. NULL은 건너뛴다.
        - 여러 칼럼이 모두 NULL인지 비교 가능
        - `(COALESCE(U_01,U_02,U_03,U_04,U_05,U_06,U_07,U_08,U_09,U_10,U_11,U_12) IS NULL)`
        - 예:
            ```SQL
            COALESCE('A', 'B', NULL) -- A 출력
            COALESCE(NULL, 'B', 'C', 'D') -- B 출력
            COALESCE(NULL, NULL) -- NULL 출력
            ```
        - 참고
            - vo.la/64tgRs
            - gent.tistory.com/479
        - 성능 비교 : COALESCE vs NVL
            - COALESCE가 빠르다.
            - dba_oracle.com/t_sql_coalesce.htm (archive.is/96h91)
            - stackoverflow.com/questions/950084 (archive.is/mUXmH)
            - han.gl/FbjFx (nimishgarg.blogspot.com) (archive.is/tysgJ)
            - hrjeong.tistory.com/208
    - GREATEST, LEAST : 여러 칼럼에서 최댓값, 최솟값 추출
        - 예
            ```SQL
            CASE WHEN (GREATEST(NVL(U_02,0),NVL(U_03,0),NVL(U_04,0),NVL(U_05,0),NVL(U_06,0)
                        ,NVL(U_07,0),NVL(U_08,0),NVL(U_09,0),NVL(U_10,0),NVL(U_11,0),NVL(U_12,0)) <= 10) THEN 1
            ELSE 0 END AS U_ALL_LOWER_THAN_10_YN
            ```
        - 참고
            - gent.tistory.com/332

- sql 파일 내에서도 구간 정하기 (분할)
    - / (슬래시) 기호 넣기
    - 함수 등에서 불필요한 주석이 안 들어가게 설정 가능

- Toad에서 회색 수직선 제거
    - View > Toad Options > Editor > Display
    - 오른쪽에서 Edge 찾아 None으로 변경

- 재귀
    - camel-context.tistory.com/16
    - thebook.io/006696/part01/ch07/02/02
    - heodolf.tistory.com/72

- 반복문 (FOR, WHILE, LOOP)
    - coding-factory.tistory.com/452

- 뷰
    - 만들기
        ```SQL
        CREATE OR REPLACE VIEW V_TEST
        AS
        SELECT * FROM TEST.TEST1
        ```
        - gent.tistory.com/361

- TRIM, LPAD, RPAD, LTRIM, RTRIM
    ```SQL
    -- TRIM으로 양쪽 잘라내기
    SELECT TRIM(BOTH '%' FROM '%ABCDE%') FROM DUAL;

    -- LPAD, RPAD(값, 총 길이, 채울 값)
    LPAD(1,4,'0')
    RPAD(1,4,'0')

    -- 주의 : 채울 값이 앞에 이미 있을 때
    -- 앞에 0이 1개 있어도 결과는 0001. (어쨌든 총 길이 4가 나올 때까지 앞에 0을 채웠으니까) 
    SELECT LPAD('01',4,'0') 

    -- 기본값은 공백 제거
    LTRIM(' LEFT SPACE') -- 결과 : LEFT SPACE. 왼쪽 공백 제거되어 출력
    LTRIM('00100', '0')  -- 왼쪽의 0 빼고 출력

    ```
    - 참고 : studyingazae.tistory.com/119 (archive.is/innzD)
        - han.gl/QqZeks (forums.oracle.com)


- 문자열을 특정 글자 수까지만 저장
    ```SQL
    SELECT
        SUBSTR(T1, 1, LEAST(5, LENGTH(T1))) AS R1
    FROM (
        SELECT '123456789' AS T1 FROM DUAL
    )
    ;
    ```
    - 출처: 인터넷 어딘가에서 봤다...


- WHERE CASE WHEN
    - WHERE절에서도 값에 따라 조건을 다르게 설정하고 싶을 때 (다중조건, 다중 조건)
    - 파라미터와 조건을 함께 묶는다
    - 예
        ```SQL
        WHERE (TEST1 = 0
                    OR (TEST1 = 1 AND TEST2.TEST2COLUMN = 1)
                    OR (TEST1 = 2 AND TEST2.TEST2COLUMN = 2)
                    OR (TEST1 = 3 AND TEST2.TEST2COLUMN IN (1,2))
                    OR (TEST1 = 4 AND TEST2.TEST2COLUMN = 0))
        ```
        - TEST1에 따라 TEST2.TEST2COLUMN 조건이 달라진다.
    - 참고
        - www.gurubee.net/article/80668 (archive.is/TV1ad)
        - wakestand.tistory.com/402 (archive.is/rEt0b)

- FORALL 문
    - han.gl/gKuyO (thebook.io, archive.is/SCHgy)

- BULK COLLECT
    - 참고
        - farmerkyh.tistory.com/241 (archive.is/ARYU9)
        - han.gl/PqXvHe (blog.naver.com/inhim/100154127152, archive.is/BaHZv)
        - han.gl/pBvmWK (stevenfeuersteinonplsql.blogspot.com, archive.is/PkLhe)
        - han.gl/oFggxq (forums.oracle.com, archive.is/Ii5ND)

- 테이블 전체 ROW 수 구하기
    ```sql
    SELECT TABLE_NAME, NUM_ROWS
    FROM DBA_TABLES
    WHERE OWNER = 'TEST'
    ;
    ```
    - 참고: vo.la/xJn22 (stackoverflow.com/questions/16219537)



- 테이블에서 테이블,뷰,패키지 등 여부 확인
    ```sql
    SELECT *
    FROM ALL_OBJECTS
    WHERE OBJECT_TYPE IN ('TABLE', 'VIEW')
    ``` 
    - 참고: vo.la/mgZfE (stackoverflow.com/questions/31853558)

- 테이블 칼럼이 가상 칼럼인지 확인
    ```sql
    SELECT *
    FROM ALL_TAB_COLS
    WHERE VIRTUAL_COLUMN = 'YES'    -- YES면 가상 칼럼, NO면 진짜 칼럼
    ```
    - 참고: vo.la/nCipu (stackoverflow.com/questions/8074963)


- 가상 칼럼을 나누기로 설정 시 0으로 나누기(Dividing by zero) 오류 피하기
    - `SELECT a/NULLIF(b,0) FROM TEST_TABLE`
    - 참고: vo.la/mTYfb (www.airops.com, archive.is/CIx73)

-----------------------------
## 부록
- 엑셀 행 너비 글자에 맞춰 조절하기
    - 1개 or 여러 항목 선택 후(=1줄 전체) 알파벳 사이 선 더블클릭
- Navigator 창 띄우기 (왼쪽에 뜨는 거)
	- Editor > Desktop Panels > Navigator

- 책
	- 오라클 SQL과 PL/SQL을 다루는 기술 (thebook.io/006696)
- 강의
	- 오라클 교과서 - youtube (vo.la/j7wN0q)
- 사이트
    - 성능 향상을 위한 SQL 작성법 (d2.naver.com/helloworld/1155)
	

### 정규표현식
- hamait.tistory.com/342 (archive.is/JVYZa)
- 정규표현식 예시 : youngjinmo.github.io/2020/01/reg (archive.is/9oEtb)
- 오라클에서 정규표현식 쓰는 함수들 : vo.la/Barae0
- 한글 정규표현식 : wintness.tistory.com/173
    - 범위 : 가-힣(유니코드), 가-힝(KSC5601 또는 MSWIN949)
        - www.gurubee.net/article/66588
        - KSC5601에서 똠,펲,샾,잌 등의 글자는 깨지기 때문에 활용 불가 (vo.la/EscSt appletong.com)
- 기호 설명 : highcode.tistory.com/6
- 기타 테크닉 : vo.la/fmswvk
- REGEXP_SUBSTR
    - 동명에서 숫자, 영어만 선택
        SELECT 
            REGEXP_SUBSTR(TEST1, '[0-9]+') AS REGEX_TEST    -- 숫자
            , REGEXP_SUBSTR(TEST1, '[a-zA-Z]+') AS REGEX_TEST2  -- 영어
        FROM (SELECT '테스트123Test테스트' AS TEST1 FROM DUAL)
    - 동명에서 영어,숫자,한글(가장 앞)선택
        `REPLACE(REPLACE(REGEXP_SUBSTR(R3.DONG_NAME, '([0-9a-zA-Z]+)|^([a-zA-Z가나다라마]\(동\)|[a-zA-Z가나다라마]동\(동\))'), '동', ''), '()', '')`
        - 축소
            ```SQL
            -- 동
            REGEXP_REPLACE(DONG_NM, '([(동)])|([\{동\}])|\[동\]|([<동>])') AS DONG_NM

            -- 호
            REGEXP_REPLACE(HO_NM, '([(호)])|([\{호\}])|\[호\]|([<호>])') AS HO_NM
            ```
        - 참고: 220628 융자형 자료 등록.sql
        - 230416 하나 더 추가
            ```sql
            REGEXP_REPLACE(REPLACE(UPPER(P_NM_1),' ',''), '동|\([^()]*\)|\[[^()]*\]|\{[^()]*\}|\<[^()]*\>')
            ```
            - 괄호 안 문자도 제거 가능. 출처는 stackoverflow인데 자세한 주소는 찾아봐야 한다.
- 구분자별로 항목 분리
    ```SQL
    REPLACE(REGEXP_SUBSTR(PRIVACY_CONTENTS, '(.*?)(\||$)', 1, 2), '|', '')
    ```
    - REGEXP_SUBSTR로 먼저 분리 → REPLACE로 구분자 제거
    - vo.la/ZqA4X5 (archive.is/YN0ww)
- 앞의 연번(번호)제거
    ```SQL
    SELECT REGEXP_REPLACE(T1, '((\d+).)(+\s?)') AS R1
    FROM (SELECT '63 서울특별시 금천구 s' AS T1 FROM DUAL);
    ```
    - ((\d+).) : 앞에 숫자가 (1자리든 여러 자리든 상관 없이) 오고 그 뒤에 점이 온다.
    - (+\s?) : 그 뒤에 공백이 이어서 올 수도 있고 안 올 수도 있다.
    - 참고 : han.gl/KZmcz
- 특정 단어 전체가 문장에 있는지 확인 (=Whole words only)
    - 참고 : stackoverflow.com/questions/7567700 (archive.is/QbIRA)
    - 예 :
        ```sql
        SELECT 1 FROM DUAL
        WHERE REGEXP_INSTR ('[TEST]DOES WORK HERE', '(^|\s|\W)TEST($|\s|\W)') > 0;
        ```
- 공백 기준으로 구분
    - 예
        ```sql
        -- 시도, 시군구(2글자씩)
        SELECT
            TRIM(REGEXP_SUBSTR(:P_FULL_ADDR, '[^ ]+', 1, 1))||' '||SUBSTR(TRIM(REGEXP_SUBSTR(:P_FULL_ADDR, '[^ ]+', 1, 2)),1,2) AS SIDO_NM
        FROM DUAL
        ;

        -- 구역명
        SELECT
            LISTAGG(T1, ' ') WITHIN GROUP(ORDER BY LVL) AS DISTRICT_NM
        FROM (
        SELECT LEVEL AS LVL, TRIM(REGEXP_SUBSTR(:P_FULL_ADDR, '[^ ]+', 1, LEVEL)) AS T1
        FROM DUAL
        WHERE LEVEL >= 3
        CONNECT BY LEVEL < REGEXP_COUNT(:P_FULL_ADDR, '[^ ]+')
        )
        ```
- 특정 문자열에서 공백이 있는지 찾기
    ```sql
    SELECT *
    FROM TEST_TABLE
    WHERE REGEXP_REPLACE(COLUMN_NAME, '[[:space:]]');
    ```
    - 출처: stackoverflow.com/questions/31466930 (archive.is/6n1xf)

- 특정 문자열이 숫자만으로 이루어졌는지 확인
    ```sql
    SELECT REGEXP_SUBSTR(T1, '^[[:digit:]]+$') AS R1
    FROM DUAL;

    -- 특정 문자열이 NULL이거나 숫자가 아니면 0, 숫자면 1
    SELECT COALESCE(REGEXP_INSTR(T1, '^[[:digit:]]+$'), 0) FROM DUAL;
    ```
    - 출처: stackoverflow.com/questions/28819709 (archive.is/tgMBE)

- 문자열 2개 자리 바꾸기
    - 예 : COLUMN A TO B; → COLUMN B TO A;
    - Notepad++에서 실행
    - 찾을 내용: `COLUMN (.*) TO (.*);$`
    - 바꿀 내용: `COLUMN $2 TO $1;`
    - 세미콜론 등 뺄 특수문자는 밖에 따로 작성
    - 출처
        - han.gl/klHek (stackoverflow.com, archive.is/YdJ9d)
        - han.gl/vBEkJ (stackoverflow.com, archive.is/4tIdn)

    - 응용: 문자열 교체
        ```
        1.
        찾을: , 0 AS (.*)$
        바꿀: , BOI.$1 = U.$1

        2.
        찾을: AND (.*) = (.*)$
        바꿀: AND COALESCE\($1, '-1'\) = COALESCE\($2, '-1'\)
        ```

- 앞에 붙어있는 숫자 제거 (PowerRename 등 활용)
    - `^[\d-]*\s*` 이용
    - 참고: han.gl/WpbbUq (stackoverflow.com/questions/3558578, archive.is/ffbQm)

- V_SQL 등 VARCHAR2 변수에 쿼리 저장
    - notepad++에서 정규표현식 선택 후 바꾸기
        - 찾을 내용: (.*)
        - 바꿀 내용: V_SQL := V_SQL||q'[$1 ]';